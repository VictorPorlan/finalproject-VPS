# TradeBinder Backend - Cursor Rules

## Contexto del Proyecto
Este es el backend de TradeBinder, una plataforma web para compra/venta de cartas de Magic: The Gathering. 
TecnologÃ­as: NestJS, PostgreSQL, TypeORM/Prisma, JWT, Docker.

## Arquitectura y Patrones
- **Arquitectura**: Modular con NestJS (mÃ³dulos, controladores, servicios, entidades)
- **PatrÃ³n**: Repository/Service pattern con inyecciÃ³n de dependencias
- **ORM**: TypeORM o Prisma para PostgreSQL
- **AutenticaciÃ³n**: JWT con guards y middleware de seguridad
- **ValidaciÃ³n**: DTOs con class-validator y class-transformer

## Estructura de Archivos
```
/backend
â”œâ”€â”€ /src
â”‚   â”œâ”€â”€ /modules          # MÃ³dulos de funcionalidad (auth, announcements, messages)
â”‚   â”œâ”€â”€ /controllers      # Controladores REST
â”‚   â”œâ”€â”€ /services         # LÃ³gica de negocio
â”‚   â”œâ”€â”€ /entities         # Entidades de base de datos
â”‚   â”œâ”€â”€ /dto              # Data Transfer Objects
â”‚   â”œâ”€â”€ /guards           # Guards de autenticaciÃ³n/autorizaciÃ³n
â”‚   â”œâ”€â”€ /middlewares      # Middlewares personalizados
â”‚   â”œâ”€â”€ /interceptors     # Interceptors para transformaciÃ³n
â”‚   â”œâ”€â”€ /pipes            # Pipes de validaciÃ³n
â”‚   â””â”€â”€ main.ts
â”œâ”€â”€ /db
â”‚   â”œâ”€â”€ /migrations
â”‚   â””â”€â”€ /seeds
â””â”€â”€ docker-compose.yml
```

## Buenas PrÃ¡cticas Backend

### CÃ³digo y Estructura
- Usar decoradores de NestJS (@Controller, @Service, @Injectable)
- Implementar DTOs para validaciÃ³n de entrada y salida
- Separar lÃ³gica de negocio en servicios, no en controladores
- Usar inyecciÃ³n de dependencias correctamente
- Implementar guards para rutas protegidas
- Usar pipes para validaciÃ³n y transformaciÃ³n de datos

### Base de Datos
- Crear entidades con decoradores de TypeORM (@Entity, @Column, @PrimaryGeneratedColumn)
- Definir relaciones correctamente (@OneToMany, @ManyToOne, @ManyToMany)
- Usar migraciones para cambios de esquema
- Implementar seeds para datos de prueba
- AÃ±adir Ã­ndices para consultas frecuentes

### Seguridad
- Hash de contraseÃ±as con bcrypt
- ValidaciÃ³n de inputs con class-validator
- CORS configurado apropiadamente
- Rate limiting en endpoints sensibles
- PrevenciÃ³n de inyecciones SQL mediante ORM
- JWT con expiraciÃ³n apropiada

### API REST
- Seguir convenciones REST (GET, POST, PUT, DELETE)
- Usar cÃ³digos de estado HTTP apropiados
- Implementar paginaciÃ³n en listados
- Documentar endpoints con Swagger/OpenAPI
- Manejar errores de forma consistente

### Testing
- Unit tests para servicios
- Integration tests para controladores
- E2E tests para flujos completos
- Mock de dependencias externas
- Cobertura de cÃ³digo mÃ­nima del 80%

## GestiÃ³n de Tickets y Progreso

### ğŸ« Sistema de Tickets
**IMPORTANTE**: El desarrollo debe basarse en los tickets definidos en `/ia-doc/tickets-backend.md`

**Flujo de Trabajo con Tickets:**
1. **Consultar tickets disponibles** en `/ia-doc/tickets-backend.md`
2. **Seleccionar ticket** segÃºn prioridad y dependencias
3. **Marcar tareas como completadas** usando checkboxes `- [x]`
4. **Actualizar progreso** en tiempo real
5. **Marcar ticket como finalizado** cuando todos los criterios de aceptaciÃ³n se cumplan

**Formato de Seguimiento:**
```markdown
### Tareas
- [x] Tarea completada
- [ ] Tarea pendiente
- [ğŸ”„] Tarea en progreso

### Criterios de AceptaciÃ³n
- [x] Criterio cumplido
- [ ] Criterio pendiente
```

**Marcado de Progreso:**
- `- [x]` - Tarea completada
- `- [ ]` - Tarea pendiente  
- `- [ğŸ”„]` - Tarea en progreso
- `- [âŒ]` - Tarea bloqueada o con problemas

### ğŸ“Š Seguimiento de Progreso
- **Actualizar tickets** despuÃ©s de cada sesiÃ³n de trabajo
- **Marcar criterios de aceptaciÃ³n** cuando se cumplan
- **Documentar decisiones tÃ©cnicas** en cada ticket
- **Mantener historial** de cambios en tickets

## DocumentaciÃ³n y Logging

### Logging de Conversaciones IA
**IMPORTANTE**: Mantener un registro completo de todas las conversaciones con IA en `/ia-doc/prompts.md`

Para cada interacciÃ³n con IA, documentar:
1. **Fecha y hora** de la conversaciÃ³n
2. **Prompt del usuario** (texto completo)
3. **Respuesta de la IA** (resumen de la soluciÃ³n propuesta)
4. **Archivos modificados** o creados
5. **Decisiones tÃ©cnicas** tomadas
6. **PrÃ³ximos pasos** identificados

Formato sugerido:
```markdown
## [YYYY-MM-DD HH:MM] - [TÃ­tulo de la tarea]

**Prompt del usuario:**
[Texto completo del prompt]

**Respuesta de la IA:**
[Resumen de la soluciÃ³n implementada]

**Archivos modificados:**
- archivo1.ts
- archivo2.ts

**Decisiones tÃ©cnicas:**
- [DecisiÃ³n 1]
- [DecisiÃ³n 2]

**PrÃ³ximos pasos:**
- [Tarea 1]
- [Tarea 2]
```

### DocumentaciÃ³n TÃ©cnica
- Comentar cÃ³digo complejo
- Mantener README actualizado
- Documentar decisiones de arquitectura
- Crear diagramas de flujo cuando sea necesario

## Convenciones de CÃ³digo

### Naming
- Variables y funciones: camelCase
- Clases y interfaces: PascalCase
- Constantes: UPPER_SNAKE_CASE
- Archivos: kebab-case.ts
- MÃ³dulos: PascalCase

### Imports
- Imports de librerÃ­as externas primero
- Imports relativos despuÃ©s
- Agrupar por tipo (entities, services, controllers)

### Error Handling
- Usar excepciones HTTP de NestJS (BadRequestException, NotFoundException)
- Implementar filtros globales de excepciones
- Logging de errores con contexto apropiado
- Respuestas de error consistentes

## Comandos Ãštiles
```bash
# Desarrollo
npm run start:dev

# Testing
npm run test
npm run test:e2e

# Base de datos
npm run migration:generate
npm run migration:run
npm run seed:run

# Build
npm run build
```

## Consideraciones Especiales
- El proyecto serÃ¡ evaluado por habilidades con IA
- Mantener documentaciÃ³n completa de decisiones tÃ©cnicas
- Priorizar cÃ³digo limpio y mantenible
- Implementar funcionalidades paso a paso siguiendo las historias de usuario
- Usar Docker para consistencia de entorno de desarrollo
