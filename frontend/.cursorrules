# TradeBinder Frontend - Cursor Rules

## Contexto del Proyecto
Este es el frontend de TradeBinder, una plataforma web para compra/venta de cartas de Magic: The Gathering.
TecnologÃ­as: React, MaterialUI, Tailwind CSS, Context API/Redux, Axios/Fetch.

## Arquitectura y Patrones
- **Arquitectura**: SPA (Single Page Application) con React
- **PatrÃ³n**: Component-based architecture con hooks
- **Estado**: Context API o Redux para estado global
- **Routing**: React Router para navegaciÃ³n
- **UI**: MaterialUI + Tailwind CSS para diseÃ±o
- **HTTP**: Axios o Fetch para comunicaciÃ³n con API

## Estructura de Archivos
```
/frontend
â”œâ”€â”€ /public
â”‚   â”œâ”€â”€ index.html
â”‚   â””â”€â”€ favicon.ico
â”œâ”€â”€ /src
â”‚   â”œâ”€â”€ /components      # Componentes reutilizables
â”‚   â”‚   â”œâ”€â”€ /common     # Componentes comunes (Button, Input, Modal)
â”‚   â”‚   â”œâ”€â”€ /layout     # Componentes de layout (Header, Footer, Sidebar)
â”‚   â”‚   â””â”€â”€ /features   # Componentes especÃ­ficos de funcionalidad
â”‚   â”œâ”€â”€ /pages          # PÃ¡ginas principales
â”‚   â”‚   â”œâ”€â”€ Home.tsx
â”‚   â”‚   â”œâ”€â”€ Login.tsx
â”‚   â”‚   â”œâ”€â”€ Register.tsx
â”‚   â”‚   â”œâ”€â”€ Announcements.tsx
â”‚   â”‚   â””â”€â”€ Profile.tsx
â”‚   â”œâ”€â”€ /services       # Servicios para API calls
â”‚   â”œâ”€â”€ /context        # Context providers
â”‚   â”œâ”€â”€ /hooks          # Custom hooks
â”‚   â”œâ”€â”€ /utils          # Utilidades y helpers
â”‚   â”œâ”€â”€ /types          # TypeScript type definitions
â”‚   â”œâ”€â”€ /assets         # ImÃ¡genes, iconos, etc.
â”‚   â”œâ”€â”€ App.tsx
â”‚   â””â”€â”€ index.tsx
â””â”€â”€ package.json
```

## Buenas PrÃ¡cticas Frontend

### Componentes React
- Usar functional components con hooks
- Implementar TypeScript para type safety
- Crear componentes reutilizables y modulares
- Usar props drilling mÃ­nimo, preferir Context API
- Implementar error boundaries para manejo de errores
- Usar React.memo para optimizaciÃ³n cuando sea necesario

### Estado y Datos
- Context API para estado global (autenticaciÃ³n, usuario)
- useState para estado local de componentes
- useEffect para side effects y llamadas a API
- Custom hooks para lÃ³gica reutilizable
- Manejar estados de carga y error apropiadamente

### UI/UX
- MaterialUI para componentes base y sistema de diseÃ±o
- Tailwind CSS para estilos personalizados y responsive design
- DiseÃ±o mobile-first
- Implementar loading states y skeletons
- Mensajes de error claros y user-friendly
- NavegaciÃ³n intuitiva y accesible

### ComunicaciÃ³n con API
- Servicios centralizados para llamadas a API
- Interceptors para manejo de tokens JWT
- Manejo de errores HTTP consistente
- Implementar retry logic para requests fallidos
- Loading states durante llamadas asÃ­ncronas

### Routing y NavegaciÃ³n
- React Router para navegaciÃ³n SPA
- Rutas protegidas para usuarios autenticados
- Redirects apropiados despuÃ©s de login/logout
- Breadcrumbs para navegaciÃ³n compleja
- Manejo de rutas 404

### Performance
- Lazy loading de componentes pesados
- Code splitting por rutas
- OptimizaciÃ³n de imÃ¡genes
- MemoizaciÃ³n de componentes costosos
- Bundle analysis para identificar optimizaciones

## GestiÃ³n de Tickets y Progreso

### ğŸ« Sistema de Tickets
**IMPORTANTE**: El desarrollo debe basarse en los tickets definidos en `/ia-doc/tickets-frontend.md`

**Flujo de Trabajo con Tickets:**
1. **Consultar tickets disponibles** en `/ia-doc/tickets-frontend.md`
2. **Seleccionar ticket** segÃºn prioridad y dependencias
3. **Marcar tareas como completadas** usando checkboxes `- [x]`
4. **Actualizar progreso** en tiempo real
5. **Marcar ticket como finalizado** cuando todos los criterios de aceptaciÃ³n se cumplan

**Formato de Seguimiento:**
```markdown
### Tareas
- [x] Tarea completada
- [ ] Tarea pendiente
- [ğŸ”„] Tarea en progreso

### Criterios de AceptaciÃ³n
- [x] Criterio cumplido
- [ ] Criterio pendiente
```

**Marcado de Progreso:**
- `- [x]` - Tarea completada
- `- [ ]` - Tarea pendiente  
- `- [ğŸ”„]` - Tarea en progreso
- `- [âŒ]` - Tarea bloqueada o con problemas

### ğŸ“Š Seguimiento de Progreso
- **Actualizar tickets** despuÃ©s de cada sesiÃ³n de trabajo
- **Marcar criterios de aceptaciÃ³n** cuando se cumplan
- **Documentar decisiones tÃ©cnicas** en cada ticket
- **Mantener historial** de cambios en tickets

## DocumentaciÃ³n y Logging

### Logging de Conversaciones IA
**IMPORTANTE**: Mantener un registro completo de todas las conversaciones con IA en `/ia-doc/prompts.md`

Para cada interacciÃ³n con IA, documentar:
1. **Fecha y hora** de la conversaciÃ³n
2. **Prompt del usuario** (texto completo)
3. **Respuesta de la IA** (resumen de la soluciÃ³n propuesta)
4. **Componentes creados/modificados**
5. **Decisiones de UI/UX** tomadas
6. **PrÃ³ximos pasos** identificados

Formato sugerido:
```markdown
## [YYYY-MM-DD HH:MM] - [TÃ­tulo de la tarea]

**Prompt del usuario:**
[Texto completo del prompt]

**Respuesta de la IA:**
[Resumen de la soluciÃ³n implementada]

**Componentes modificados:**
- ComponentName.tsx
- PageName.tsx

**Decisiones de UI/UX:**
- [DecisiÃ³n 1]
- [DecisiÃ³n 2]

**PrÃ³ximos pasos:**
- [Tarea 1]
- [Tarea 2]
```

### DocumentaciÃ³n TÃ©cnica
- Documentar props de componentes complejos
- Comentar lÃ³gica de negocio compleja
- Mantener README actualizado
- Documentar decisiones de diseÃ±o
- Crear storybook para componentes (opcional)

## Convenciones de CÃ³digo

### Naming
- Componentes: PascalCase (UserProfile.tsx)
- Archivos: PascalCase para componentes, camelCase para utilities
- Variables y funciones: camelCase
- Constantes: UPPER_SNAKE_CASE
- Props interfaces: ComponentNameProps

### Imports
- Imports de React primero
- Imports de librerÃ­as externas (MaterialUI, etc.)
- Imports relativos despuÃ©s
- Agrupar por tipo (components, services, types)

### JSX
- Usar fragmentos (<>) cuando sea necesario
- Props en lÃ­neas separadas para componentes complejos
- Usar destructuring para props
- Conditional rendering con operadores ternarios o &&

### Styling
- MaterialUI para componentes base
- Tailwind CSS para estilos personalizados
- CSS modules solo cuando sea necesario
- Responsive design con breakpoints de Tailwind
- Consistencia en spacing y colors

## Testing

### Estrategia de Testing
- Unit tests para componentes con React Testing Library
- Integration tests para flujos de usuario
- Snapshot tests para componentes estables
- Mock de servicios externos
- Testing de hooks personalizados

### Herramientas
- Jest para test runner
- React Testing Library para testing de componentes
- MSW para mock de API calls
- Coverage mÃ­nimo del 80%

## Comandos Ãštiles
```bash
# Desarrollo
npm start

# Testing
npm test
npm run test:coverage

# Build
npm run build

# Linting
npm run lint
npm run lint:fix

# Type checking
npm run type-check
```

## Consideraciones Especiales
- El proyecto serÃ¡ evaluado por habilidades con IA
- Mantener documentaciÃ³n completa de decisiones tÃ©cnicas
- Priorizar experiencia de usuario fluida
- Implementar funcionalidades siguiendo las historias de usuario
- DiseÃ±o responsive y accesible
- Performance optimizada para mÃ³viles
- IntegraciÃ³n fluida con backend NestJS
